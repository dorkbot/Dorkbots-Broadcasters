package dorkbots.dorkbots_ui {	import flash.text.TextField;

	public class TruncateTextField 	{		public function TruncateTextField ()		{					}				public static function truncateText( textField:TextField, addEllipsis:Boolean = true, minimizeLines:uint = 0, ellipsis:String = "\u2026" ):uint		{			var tempTextField:TextField;						var characterRemoveCnt:uint = 0;						if ( ! textOverflowing( textField ) ) return characterRemoveCnt;						tempTextField = copyTextField( textField );						while( textOverflowing( tempTextField, minimizeLines, ellipsis ) )			{				characterRemoveCnt++;				tempTextField.text = tempTextField.text.substr( 0, tempTextField.text.length - 1 );			}						// Remove any empty spaces and periods at the end			var continueEndTidying:Boolean = true;			while(continueEndTidying)			{				continueEndTidying = false;								if (tempTextField.text.charAt(tempTextField.text.length - 1) == " ") continueEndTidying = true;				// remove any periods if we are adding ellipsis				if (addEllipsis && tempTextField.text.charAt(tempTextField.text.length - 1) == ".") continueEndTidying = true;								if (continueEndTidying)				{					characterRemoveCnt++;					tempTextField.text = tempTextField.text.slice(0, -1);				}								// just in case, because while loops make me nervous				if (tempTextField.text.length <= 0) break;			}						// add ellipsis			if (ellipsis)			{				tempTextField.appendText( ellipsis );								if (tempTextField.numLines > 1) 				{					// check again, for some reason, adding the ellipsis can increase number of lines					while( textOverflowing( tempTextField, minimizeLines, ellipsis ) )					{						characterRemoveCnt++;						tempTextField.text = tempTextField.text.substr( 0, tempTextField.text.length - ellipsis.length - 1 );					}				}								tempTextField.appendText( ellipsis );			}						textField.text = tempTextField.text;						return characterRemoveCnt;		}				private static function textOverflowing( textField:TextField, minimizeLines:uint = 0, suffix:String = null ):Boolean		{			var margin:Number = 4; //Flash adds this to all textfields;						var tempTextField:TextField = copyTextField( textField );						if ( suffix ) tempTextField.appendText( suffix );						if (minimizeLines > 0 && tempTextField.numLines > minimizeLines) 			{				return true;			}						if ( tempTextField.textWidth > tempTextField.width - margin || tempTextField.textHeight > tempTextField.height - margin ) return true;						return false;		}				private static function copyTextField( original:TextField ):TextField		{			var copy:TextField = new TextField();						copy.width = original.width;			copy.height = original.height;			copy.multiline = original.multiline;			copy.wordWrap = original.wordWrap;			copy.embedFonts = original.embedFonts;			copy.antiAliasType = original.antiAliasType;			copy.autoSize = original.autoSize;			copy.defaultTextFormat = original.getTextFormat();			copy.text = original.text;						return copy;		}				/**		 * Truncate html text.		 * @param value The original text value		 * @param limit The maximum number of characters to show		 * @param addEllipsis  Boolean value to show elipses at the end of truncation.		 * @param addMoreLink  Boolean value to show a "[more]" with a TextEvent (TextEvent.LINK) at the end of truncation.		 * This method is based on Michael Ritchie's work at http://thanksmister.com/2009/07/12/flex-truncating-html-text/		 * */		public static function truncateHTMLText(value:String, limit:int, addEllipsis:Boolean = true, addMoreLink:Boolean = true):String		{				if (!addEllipsis) limit += 3;			if (!addMoreLink) limit += 6;						if(limit <= 0) return "";						var original:String = value;						value = value.replace("[\\t\\n\\x0B\\f\\r\\u00A0]+", "");						var isTag:Boolean = false;			var count:int = 0;			var position:int = 0;			var limitLength:int = value.length - 1;			var closeTag:Boolean = false;						for(var i:int = 0; i < value.length; i++) 			{				var c:String = value.charAt(i);				if(isTag) 				{					if(c == '>') 					{						isTag = false;						if(closeTag || i == limitLength) 						{							position = i;							break;						}						continue;					} 					else 					{						continue;					}				} 				else 				{					if(c == '<') 					{						isTag = true;					} 					else 					{						count++;						if(i == limitLength || (count == limit)) 						{							if(((i+1) < limitLength) && ((i+2) < limitLength)) 							{								if(value.charAt(i+1) == '<' && value.charAt(i+2) == '/') 								{									closeTag = true;									continue;								}							}							position = i;							break;						}					}				}			}						var result:String = value.substring(0, position + 1);			var last:String = result.charAt(result.length - 1);			var length:int = result.length;						var nextChar:String = (length >= value.length) ? ' ' : value.charAt(length);						if(last != ' ' && last != '>' && nextChar != ' ' && nextChar != '<')			{				result = result.substring(0, result.lastIndexOf(' ') + 1);			}			var lastStartTag:int = result.lastIndexOf('<');						if(lastStartTag != -1)			{				var ch:String = result.charAt(lastStartTag + 1);				if(ch != '/') 				{					result = result.substring(0, lastStartTag);				}			}						if(original.length == result.length) return original;						if(result.length == 0) return result;						// Remove any empty spaces and periods at the end			while(result.charAt(result.length - 1) == " " || result.charAt(result.length - 1) == ".")			{				result = result.slice(0, -1);				// just incase, because while loops make me nervous				if (result.length <= 0) break;			}						// Remove any empty spaces and periods at the end			var continueEndTidying:Boolean = true;			while(continueEndTidying)			{				continueEndTidying = false;								if (result.charAt(result.length - 1) == " ") continueEndTidying = true;				// remove any periods if we are adding ellipsis				if (addEllipsis && result.charAt(result.length - 1) == ".") continueEndTidying = true;								if (continueEndTidying)				{					result = result.slice(0, -1);				}								// just in case, because while loops make me nervous				if (result.length <= 0) break;			}												var pattern:RegExp = new RegExp("(.*?)(\\s*\.\.\.\\s*)([\</[a-z]*?\>\\s*$]+)", "i");						if(result.search(pattern) == -1 && addEllipsis) result += "...";						if (addMoreLink)			{				return (result +  " <a href=\"event:more\">[more]</a>");			}			else			{				return result;			}		}	}}